/* automatically generated by rust-bindgen 0.69.4 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C2X_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 39;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirLlvmThreadPool {
    #[doc = " Re-export llvm::ThreadPool so as to avoid including the LLVM C API directly."]
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirLlvmThreadPool() {
    const UNINIT: ::std::mem::MaybeUninit<MlirLlvmThreadPool> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirLlvmThreadPool>(),
        8usize,
        concat!("Size of: ", stringify!(MlirLlvmThreadPool))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirLlvmThreadPool>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirLlvmThreadPool))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirLlvmThreadPool),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirTypeID {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirTypeID() {
    const UNINIT: ::std::mem::MaybeUninit<MlirTypeID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirTypeID>(),
        8usize,
        concat!("Size of: ", stringify!(MlirTypeID))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirTypeID>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirTypeID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirTypeID),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirTypeIDAllocator {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirTypeIDAllocator() {
    const UNINIT: ::std::mem::MaybeUninit<MlirTypeIDAllocator> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirTypeIDAllocator>(),
        8usize,
        concat!("Size of: ", stringify!(MlirTypeIDAllocator))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirTypeIDAllocator>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirTypeIDAllocator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirTypeIDAllocator),
            "::",
            stringify!(ptr)
        )
    );
}
#[doc = " A pointer to a sized fragment of a string, not necessarily null-terminated.\n Does not own the underlying string. This is equivalent to llvm::StringRef."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirStringRef {
    #[doc = "< Pointer to the first symbol."]
    pub data: *const ::std::os::raw::c_char,
    #[doc = "< Length of the fragment."]
    pub length: usize,
}
#[test]
fn bindgen_test_layout_MlirStringRef() {
    const UNINIT: ::std::mem::MaybeUninit<MlirStringRef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirStringRef>(),
        16usize,
        concat!("Size of: ", stringify!(MlirStringRef))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirStringRef>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirStringRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirStringRef),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirStringRef),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    #[doc = " Constructs a string reference from a null-terminated C string. Prefer\n mlirStringRefCreate if the length of the string is known."]
    pub fn mlirStringRefCreateFromCString(str_: *const ::std::os::raw::c_char) -> MlirStringRef;
}
extern "C" {
    #[doc = " Returns true if two string references are equal, false otherwise."]
    pub fn mlirStringRefEqual(string: MlirStringRef, other: MlirStringRef) -> bool;
}
#[doc = " A callback for returning string references.\n\n This function is called back by the functions that need to return a\n reference to the portion of the string with the following arguments:\n  - an MlirStringRef representing the current portion of the string\n  - a pointer to user data forwarded from the printing call."]
pub type MlirStringCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: MlirStringRef, arg2: *mut ::std::os::raw::c_void),
>;
#[doc = " A logical result value, essentially a boolean with named states. LLVM\n convention for using boolean values to designate success or failure of an\n operation is a moving target, so MLIR opted for an explicit class.\n Instances of MlirLogicalResult must only be inspected using the associated\n functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirLogicalResult {
    pub value: i8,
}
#[test]
fn bindgen_test_layout_MlirLogicalResult() {
    const UNINIT: ::std::mem::MaybeUninit<MlirLogicalResult> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirLogicalResult>(),
        1usize,
        concat!("Size of: ", stringify!(MlirLogicalResult))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirLogicalResult>(),
        1usize,
        concat!("Alignment of ", stringify!(MlirLogicalResult))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirLogicalResult),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " Create an LLVM thread pool. This is reexported here to avoid directly\n pulling in the LLVM headers directly."]
    pub fn mlirLlvmThreadPoolCreate() -> MlirLlvmThreadPool;
}
extern "C" {
    #[doc = " Destroy an LLVM thread pool."]
    pub fn mlirLlvmThreadPoolDestroy(pool: MlirLlvmThreadPool);
}
extern "C" {
    #[doc = " `ptr` must be 8 byte aligned and unique to a type valid for the duration of\n the returned type id's usage"]
    pub fn mlirTypeIDCreate(ptr: *const ::std::os::raw::c_void) -> MlirTypeID;
}
extern "C" {
    #[doc = " Checks if two type ids are equal."]
    pub fn mlirTypeIDEqual(typeID1: MlirTypeID, typeID2: MlirTypeID) -> bool;
}
extern "C" {
    #[doc = " Returns the hash value of the type id."]
    pub fn mlirTypeIDHashValue(typeID: MlirTypeID) -> usize;
}
extern "C" {
    #[doc = " Creates a type id allocator for dynamic type id creation"]
    pub fn mlirTypeIDAllocatorCreate() -> MlirTypeIDAllocator;
}
extern "C" {
    #[doc = " Deallocates the allocator and all allocated type ids"]
    pub fn mlirTypeIDAllocatorDestroy(allocator: MlirTypeIDAllocator);
}
extern "C" {
    #[doc = " Allocates a type id that is valid for the lifetime of the allocator"]
    pub fn mlirTypeIDAllocatorAllocateTypeID(allocator: MlirTypeIDAllocator) -> MlirTypeID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirAsmState {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirAsmState() {
    const UNINIT: ::std::mem::MaybeUninit<MlirAsmState> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirAsmState>(),
        8usize,
        concat!("Size of: ", stringify!(MlirAsmState))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirAsmState>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirAsmState))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirAsmState),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirBytecodeWriterConfig {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirBytecodeWriterConfig() {
    const UNINIT: ::std::mem::MaybeUninit<MlirBytecodeWriterConfig> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirBytecodeWriterConfig>(),
        8usize,
        concat!("Size of: ", stringify!(MlirBytecodeWriterConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirBytecodeWriterConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirBytecodeWriterConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirBytecodeWriterConfig),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirContext {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirContext() {
    const UNINIT: ::std::mem::MaybeUninit<MlirContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirContext>(),
        8usize,
        concat!("Size of: ", stringify!(MlirContext))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirContext>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirContext),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirDialect {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirDialect() {
    const UNINIT: ::std::mem::MaybeUninit<MlirDialect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirDialect>(),
        8usize,
        concat!("Size of: ", stringify!(MlirDialect))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirDialect>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirDialect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirDialect),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirDialectRegistry {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirDialectRegistry() {
    const UNINIT: ::std::mem::MaybeUninit<MlirDialectRegistry> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirDialectRegistry>(),
        8usize,
        concat!("Size of: ", stringify!(MlirDialectRegistry))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirDialectRegistry>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirDialectRegistry))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirDialectRegistry),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirOperation {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirOperation() {
    const UNINIT: ::std::mem::MaybeUninit<MlirOperation> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirOperation>(),
        8usize,
        concat!("Size of: ", stringify!(MlirOperation))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirOperation>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirOperation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperation),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirOpOperand {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirOpOperand() {
    const UNINIT: ::std::mem::MaybeUninit<MlirOpOperand> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirOpOperand>(),
        8usize,
        concat!("Size of: ", stringify!(MlirOpOperand))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirOpOperand>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirOpOperand))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOpOperand),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirOpPrintingFlags {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirOpPrintingFlags() {
    const UNINIT: ::std::mem::MaybeUninit<MlirOpPrintingFlags> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirOpPrintingFlags>(),
        8usize,
        concat!("Size of: ", stringify!(MlirOpPrintingFlags))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirOpPrintingFlags>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirOpPrintingFlags))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOpPrintingFlags),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirBlock {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirBlock() {
    const UNINIT: ::std::mem::MaybeUninit<MlirBlock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirBlock>(),
        8usize,
        concat!("Size of: ", stringify!(MlirBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirBlock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirBlock),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirRegion {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirRegion() {
    const UNINIT: ::std::mem::MaybeUninit<MlirRegion> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirRegion>(),
        8usize,
        concat!("Size of: ", stringify!(MlirRegion))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirRegion))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirRegion),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirSymbolTable {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirSymbolTable() {
    const UNINIT: ::std::mem::MaybeUninit<MlirSymbolTable> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirSymbolTable>(),
        8usize,
        concat!("Size of: ", stringify!(MlirSymbolTable))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirSymbolTable>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirSymbolTable))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirSymbolTable),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirAttribute {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirAttribute() {
    const UNINIT: ::std::mem::MaybeUninit<MlirAttribute> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirAttribute>(),
        8usize,
        concat!("Size of: ", stringify!(MlirAttribute))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirAttribute>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirAttribute))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirAttribute),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirIdentifier {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirIdentifier() {
    const UNINIT: ::std::mem::MaybeUninit<MlirIdentifier> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirIdentifier>(),
        8usize,
        concat!("Size of: ", stringify!(MlirIdentifier))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirIdentifier>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirIdentifier))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirIdentifier),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirLocation {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirLocation() {
    const UNINIT: ::std::mem::MaybeUninit<MlirLocation> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirLocation>(),
        8usize,
        concat!("Size of: ", stringify!(MlirLocation))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirLocation>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirLocation))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirLocation),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirModule {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirModule() {
    const UNINIT: ::std::mem::MaybeUninit<MlirModule> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirModule>(),
        8usize,
        concat!("Size of: ", stringify!(MlirModule))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirModule>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirModule))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirModule),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirType {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirType() {
    const UNINIT: ::std::mem::MaybeUninit<MlirType> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirType>(),
        8usize,
        concat!("Size of: ", stringify!(MlirType))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirType>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirType))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirType),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirValue {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirValue() {
    const UNINIT: ::std::mem::MaybeUninit<MlirValue> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirValue>(),
        8usize,
        concat!("Size of: ", stringify!(MlirValue))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirValue>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirValue))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirValue),
            "::",
            stringify!(ptr)
        )
    );
}
#[doc = " Named MLIR attribute.\n\n A named attribute is essentially a (name, attribute) pair where the name is\n a string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirNamedAttribute {
    pub name: MlirIdentifier,
    pub attribute: MlirAttribute,
}
#[test]
fn bindgen_test_layout_MlirNamedAttribute() {
    const UNINIT: ::std::mem::MaybeUninit<MlirNamedAttribute> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirNamedAttribute>(),
        16usize,
        concat!("Size of: ", stringify!(MlirNamedAttribute))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirNamedAttribute>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirNamedAttribute))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirNamedAttribute),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attribute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirNamedAttribute),
            "::",
            stringify!(attribute)
        )
    );
}
extern "C" {
    #[doc = " Creates an MLIR context and transfers its ownership to the caller.\n This sets the default multithreading option (enabled)."]
    pub fn mlirContextCreate() -> MlirContext;
}
extern "C" {
    #[doc = " Creates an MLIR context with an explicit setting of the multithreading\n setting and transfers its ownership to the caller."]
    pub fn mlirContextCreateWithThreading(threadingEnabled: bool) -> MlirContext;
}
extern "C" {
    #[doc = " Creates an MLIR context, setting the multithreading setting explicitly and\n pre-loading the dialects from the provided DialectRegistry."]
    pub fn mlirContextCreateWithRegistry(
        registry: MlirDialectRegistry,
        threadingEnabled: bool,
    ) -> MlirContext;
}
extern "C" {
    #[doc = " Checks if two contexts are equal."]
    pub fn mlirContextEqual(ctx1: MlirContext, ctx2: MlirContext) -> bool;
}
extern "C" {
    #[doc = " Takes an MLIR context owned by the caller and destroys it."]
    pub fn mlirContextDestroy(context: MlirContext);
}
extern "C" {
    #[doc = " Sets whether unregistered dialects are allowed in this context."]
    pub fn mlirContextSetAllowUnregisteredDialects(context: MlirContext, allow: bool);
}
extern "C" {
    #[doc = " Returns whether the context allows unregistered dialects."]
    pub fn mlirContextGetAllowUnregisteredDialects(context: MlirContext) -> bool;
}
extern "C" {
    #[doc = " Returns the number of dialects registered with the given context. A\n registered dialect will be loaded if needed by the parser."]
    pub fn mlirContextGetNumRegisteredDialects(context: MlirContext) -> isize;
}
extern "C" {
    #[doc = " Append the contents of the given dialect registry to the registry associated\n with the context."]
    pub fn mlirContextAppendDialectRegistry(ctx: MlirContext, registry: MlirDialectRegistry);
}
extern "C" {
    #[doc = " Returns the number of dialects loaded by the context."]
    pub fn mlirContextGetNumLoadedDialects(context: MlirContext) -> isize;
}
extern "C" {
    #[doc = " Gets the dialect instance owned by the given context using the dialect\n namespace to identify it, loads (i.e., constructs the instance of) the\n dialect if necessary. If the dialect is not registered with the context,\n returns null. Use mlirContextLoad<Name>Dialect to load an unregistered\n dialect."]
    pub fn mlirContextGetOrLoadDialect(context: MlirContext, name: MlirStringRef) -> MlirDialect;
}
extern "C" {
    #[doc = " Set threading mode (must be set to false to mlir-print-ir-after-all)."]
    pub fn mlirContextEnableMultithreading(context: MlirContext, enable: bool);
}
extern "C" {
    #[doc = " Eagerly loads all available dialects registered with a context, making\n them available for use for IR construction."]
    pub fn mlirContextLoadAllAvailableDialects(context: MlirContext);
}
extern "C" {
    #[doc = " Returns whether the given fully-qualified operation (i.e.\n 'dialect.operation') is registered with the context. This will return true\n if the dialect is loaded and the operation is registered within the\n dialect."]
    pub fn mlirContextIsRegisteredOperation(context: MlirContext, name: MlirStringRef) -> bool;
}
extern "C" {
    #[doc = " Sets the thread pool of the context explicitly, enabling multithreading in\n the process. This API should be used to avoid re-creating thread pools in\n long-running applications that perform multiple compilations, see\n the C++ documentation for MLIRContext for details."]
    pub fn mlirContextSetThreadPool(context: MlirContext, threadPool: MlirLlvmThreadPool);
}
extern "C" {
    #[doc = " Returns the context that owns the dialect."]
    pub fn mlirDialectGetContext(dialect: MlirDialect) -> MlirContext;
}
extern "C" {
    #[doc = " Checks if two dialects that belong to the same context are equal. Dialects\n from different contexts will not compare equal."]
    pub fn mlirDialectEqual(dialect1: MlirDialect, dialect2: MlirDialect) -> bool;
}
extern "C" {
    #[doc = " Returns the namespace of the given dialect."]
    pub fn mlirDialectGetNamespace(dialect: MlirDialect) -> MlirStringRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirDialectHandle {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirDialectHandle() {
    const UNINIT: ::std::mem::MaybeUninit<MlirDialectHandle> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirDialectHandle>(),
        8usize,
        concat!("Size of: ", stringify!(MlirDialectHandle))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirDialectHandle>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirDialectHandle))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirDialectHandle),
            "::",
            stringify!(ptr)
        )
    );
}
extern "C" {
    #[doc = " Returns the namespace associated with the provided dialect handle."]
    pub fn mlirDialectHandleGetNamespace(arg1: MlirDialectHandle) -> MlirStringRef;
}
extern "C" {
    #[doc = " Inserts the dialect associated with the provided dialect handle into the\n provided dialect registry"]
    pub fn mlirDialectHandleInsertDialect(arg1: MlirDialectHandle, arg2: MlirDialectRegistry);
}
extern "C" {
    #[doc = " Registers the dialect associated with the provided dialect handle."]
    pub fn mlirDialectHandleRegisterDialect(arg1: MlirDialectHandle, arg2: MlirContext);
}
extern "C" {
    #[doc = " Loads the dialect associated with the provided dialect handle."]
    pub fn mlirDialectHandleLoadDialect(arg1: MlirDialectHandle, arg2: MlirContext) -> MlirDialect;
}
extern "C" {
    #[doc = " Creates a dialect registry and transfers its ownership to the caller."]
    pub fn mlirDialectRegistryCreate() -> MlirDialectRegistry;
}
extern "C" {
    #[doc = " Takes a dialect registry owned by the caller and destroys it."]
    pub fn mlirDialectRegistryDestroy(registry: MlirDialectRegistry);
}
extern "C" {
    #[doc = " Returns the underlying location attribute of this location."]
    pub fn mlirLocationGetAttribute(location: MlirLocation) -> MlirAttribute;
}
extern "C" {
    #[doc = " Creates a location from a location attribute."]
    pub fn mlirLocationFromAttribute(attribute: MlirAttribute) -> MlirLocation;
}
extern "C" {
    #[doc = " Creates an File/Line/Column location owned by the given context."]
    pub fn mlirLocationFileLineColGet(
        context: MlirContext,
        filename: MlirStringRef,
        line: ::std::os::raw::c_uint,
        col: ::std::os::raw::c_uint,
    ) -> MlirLocation;
}
extern "C" {
    #[doc = " Creates a call site location with a callee and a caller."]
    pub fn mlirLocationCallSiteGet(callee: MlirLocation, caller: MlirLocation) -> MlirLocation;
}
extern "C" {
    #[doc = " Creates a fused location with an array of locations and metadata."]
    pub fn mlirLocationFusedGet(
        ctx: MlirContext,
        nLocations: isize,
        locations: *const MlirLocation,
        metadata: MlirAttribute,
    ) -> MlirLocation;
}
extern "C" {
    #[doc = " Creates a name location owned by the given context. Providing null location\n for childLoc is allowed and if childLoc is null location, then the behavior\n is the same as having unknown child location."]
    pub fn mlirLocationNameGet(
        context: MlirContext,
        name: MlirStringRef,
        childLoc: MlirLocation,
    ) -> MlirLocation;
}
extern "C" {
    #[doc = " Creates a location with unknown position owned by the given context."]
    pub fn mlirLocationUnknownGet(context: MlirContext) -> MlirLocation;
}
extern "C" {
    #[doc = " Gets the context that a location was created with."]
    pub fn mlirLocationGetContext(location: MlirLocation) -> MlirContext;
}
extern "C" {
    #[doc = " Checks if two locations are equal."]
    pub fn mlirLocationEqual(l1: MlirLocation, l2: MlirLocation) -> bool;
}
extern "C" {
    #[doc = " Prints a location by sending chunks of the string representation and\n forwarding `userData to `callback`. Note that the callback may be called\n several times with consecutive chunks of the string."]
    pub fn mlirLocationPrint(
        location: MlirLocation,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Creates a new, empty module and transfers ownership to the caller."]
    pub fn mlirModuleCreateEmpty(location: MlirLocation) -> MlirModule;
}
extern "C" {
    #[doc = " Parses a module from the string and transfers ownership to the caller."]
    pub fn mlirModuleCreateParse(context: MlirContext, module: MlirStringRef) -> MlirModule;
}
extern "C" {
    #[doc = " Gets the context that a module was created with."]
    pub fn mlirModuleGetContext(module: MlirModule) -> MlirContext;
}
extern "C" {
    #[doc = " Gets the body of the module, i.e. the only block it contains."]
    pub fn mlirModuleGetBody(module: MlirModule) -> MlirBlock;
}
extern "C" {
    #[doc = " Takes a module owned by the caller and deletes it."]
    pub fn mlirModuleDestroy(module: MlirModule);
}
extern "C" {
    #[doc = " Views the module as a generic operation."]
    pub fn mlirModuleGetOperation(module: MlirModule) -> MlirOperation;
}
extern "C" {
    #[doc = " Views the generic operation as a module.\n The returned module is null when the input operation was not a ModuleOp."]
    pub fn mlirModuleFromOperation(op: MlirOperation) -> MlirModule;
}
#[doc = " An auxiliary class for constructing operations.\n\n This class contains all the information necessary to construct the\n operation. It owns the MlirRegions it has pointers to and does not own\n anything else. By default, the state can be constructed from a name and\n location, the latter being also used to access the context, and has no other\n components. These components can be added progressively until the operation\n is constructed. Users are not expected to rely on the internals of this\n class and should use mlirOperationState* functions instead."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirOperationState {
    pub name: MlirStringRef,
    pub location: MlirLocation,
    pub nResults: isize,
    pub results: *mut MlirType,
    pub nOperands: isize,
    pub operands: *mut MlirValue,
    pub nRegions: isize,
    pub regions: *mut MlirRegion,
    pub nSuccessors: isize,
    pub successors: *mut MlirBlock,
    pub nAttributes: isize,
    pub attributes: *mut MlirNamedAttribute,
    pub enableResultTypeInference: bool,
}
#[test]
fn bindgen_test_layout_MlirOperationState() {
    const UNINIT: ::std::mem::MaybeUninit<MlirOperationState> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<MlirOperationState>(),
        112usize,
        concat!("Size of: ", stringify!(MlirOperationState))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirOperationState>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirOperationState))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nResults) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(nResults)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).results) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(results)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nOperands) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(nOperands)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operands) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(operands)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nRegions) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(nRegions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).regions) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(regions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nSuccessors) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(nSuccessors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).successors) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(successors)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nAttributes) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(nAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).attributes) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enableResultTypeInference) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(enableResultTypeInference)
        )
    );
}
extern "C" {
    #[doc = " Constructs an operation state from a name and a location."]
    pub fn mlirOperationStateGet(name: MlirStringRef, loc: MlirLocation) -> MlirOperationState;
}
extern "C" {
    #[doc = " Adds a list of components to the operation state."]
    pub fn mlirOperationStateAddResults(
        state: *mut MlirOperationState,
        n: isize,
        results: *const MlirType,
    );
}
extern "C" {
    pub fn mlirOperationStateAddOperands(
        state: *mut MlirOperationState,
        n: isize,
        operands: *const MlirValue,
    );
}
extern "C" {
    pub fn mlirOperationStateAddOwnedRegions(
        state: *mut MlirOperationState,
        n: isize,
        regions: *const MlirRegion,
    );
}
extern "C" {
    pub fn mlirOperationStateAddSuccessors(
        state: *mut MlirOperationState,
        n: isize,
        successors: *const MlirBlock,
    );
}
extern "C" {
    pub fn mlirOperationStateAddAttributes(
        state: *mut MlirOperationState,
        n: isize,
        attributes: *const MlirNamedAttribute,
    );
}
extern "C" {
    #[doc = " Enables result type inference for the operation under construction. If\n enabled, then the caller must not have called\n mlirOperationStateAddResults(). Note that if enabled, the\n mlirOperationCreate() call is failable: it will return a null operation\n on inference failure and will emit diagnostics."]
    pub fn mlirOperationStateEnableResultTypeInference(state: *mut MlirOperationState);
}
extern "C" {
    #[doc = " Creates new AsmState, as with AsmState the IR should not be mutated\n in-between using this state.\n Must be freed with a call to mlirAsmStateDestroy()."]
    pub fn mlirAsmStateCreateForOperation(
        op: MlirOperation,
        flags: MlirOpPrintingFlags,
    ) -> MlirAsmState;
}
extern "C" {
    #[doc = " Creates new AsmState from value.\n Must be freed with a call to mlirAsmStateDestroy()."]
    pub fn mlirAsmStateCreateForValue(value: MlirValue, flags: MlirOpPrintingFlags)
        -> MlirAsmState;
}
extern "C" {
    #[doc = " Destroys printing flags created with mlirAsmStateCreate."]
    pub fn mlirAsmStateDestroy(state: MlirAsmState);
}
extern "C" {
    #[doc = " Creates new printing flags with defaults, intended for customization.\n Must be freed with a call to mlirOpPrintingFlagsDestroy()."]
    pub fn mlirOpPrintingFlagsCreate() -> MlirOpPrintingFlags;
}
extern "C" {
    #[doc = " Destroys printing flags created with mlirOpPrintingFlagsCreate."]
    pub fn mlirOpPrintingFlagsDestroy(flags: MlirOpPrintingFlags);
}
extern "C" {
    #[doc = " Enables the elision of large elements attributes by printing a lexically\n valid but otherwise meaningless form instead of the element data. The\n `largeElementLimit` is used to configure what is considered to be a \"large\"\n ElementsAttr by providing an upper limit to the number of elements."]
    pub fn mlirOpPrintingFlagsElideLargeElementsAttrs(
        flags: MlirOpPrintingFlags,
        largeElementLimit: isize,
    );
}
extern "C" {
    #[doc = " Enable or disable printing of debug information (based on `enable`). If\n 'prettyForm' is set to true, debug information is printed in a more readable\n 'pretty' form. Note: The IR generated with 'prettyForm' is not parsable."]
    pub fn mlirOpPrintingFlagsEnableDebugInfo(
        flags: MlirOpPrintingFlags,
        enable: bool,
        prettyForm: bool,
    );
}
extern "C" {
    #[doc = " Always print operations in the generic form."]
    pub fn mlirOpPrintingFlagsPrintGenericOpForm(flags: MlirOpPrintingFlags);
}
extern "C" {
    #[doc = " Use local scope when printing the operation. This allows for using the\n printer in a more localized and thread-safe setting, but may not\n necessarily be identical to what the IR will look like when dumping\n the full module."]
    pub fn mlirOpPrintingFlagsUseLocalScope(flags: MlirOpPrintingFlags);
}
extern "C" {
    #[doc = " Do not verify the operation when using custom operation printers."]
    pub fn mlirOpPrintingFlagsAssumeVerified(flags: MlirOpPrintingFlags);
}
extern "C" {
    #[doc = " Creates new printing flags with defaults, intended for customization.\n Must be freed with a call to mlirBytecodeWriterConfigDestroy()."]
    pub fn mlirBytecodeWriterConfigCreate() -> MlirBytecodeWriterConfig;
}
extern "C" {
    #[doc = " Destroys printing flags created with mlirBytecodeWriterConfigCreate."]
    pub fn mlirBytecodeWriterConfigDestroy(config: MlirBytecodeWriterConfig);
}
extern "C" {
    #[doc = " Sets the version to emit in the writer config."]
    pub fn mlirBytecodeWriterConfigDesiredEmitVersion(
        flags: MlirBytecodeWriterConfig,
        version: i64,
    );
}
extern "C" {
    #[doc = " Creates an operation and transfers ownership to the caller.\n Note that caller owned child objects are transferred in this call and must\n not be further used. Particularly, this applies to any regions added to\n the state (the implementation may invalidate any such pointers).\n\n This call can fail under the following conditions, in which case, it will\n return a null operation and emit diagnostics:\n   - Result type inference is enabled and cannot be performed."]
    pub fn mlirOperationCreate(state: *mut MlirOperationState) -> MlirOperation;
}
extern "C" {
    #[doc = " Parses an operation, giving ownership to the caller. If parsing fails a null\n operation will be returned, and an error diagnostic emitted.\n\n `sourceStr` may be either the text assembly format, or binary bytecode\n format. `sourceName` is used as the file name of the source; any IR without\n locations will get a `FileLineColLoc` location with `sourceName` as the file\n name."]
    pub fn mlirOperationCreateParse(
        context: MlirContext,
        sourceStr: MlirStringRef,
        sourceName: MlirStringRef,
    ) -> MlirOperation;
}
extern "C" {
    #[doc = " Creates a deep copy of an operation. The operation is not inserted and\n ownership is transferred to the caller."]
    pub fn mlirOperationClone(op: MlirOperation) -> MlirOperation;
}
extern "C" {
    #[doc = " Takes an operation owned by the caller and destroys it."]
    pub fn mlirOperationDestroy(op: MlirOperation);
}
extern "C" {
    #[doc = " Removes the given operation from its parent block. The operation is not\n destroyed. The ownership of the operation is transferred to the caller."]
    pub fn mlirOperationRemoveFromParent(op: MlirOperation);
}
extern "C" {
    #[doc = " Checks whether two operation handles point to the same operation. This does\n not perform deep comparison."]
    pub fn mlirOperationEqual(op: MlirOperation, other: MlirOperation) -> bool;
}
extern "C" {
    #[doc = " Gets the context this operation is associated with"]
    pub fn mlirOperationGetContext(op: MlirOperation) -> MlirContext;
}
extern "C" {
    #[doc = " Gets the location of the operation."]
    pub fn mlirOperationGetLocation(op: MlirOperation) -> MlirLocation;
}
extern "C" {
    #[doc = " Gets the type id of the operation.\n Returns null if the operation does not have a registered operation\n description."]
    pub fn mlirOperationGetTypeID(op: MlirOperation) -> MlirTypeID;
}
extern "C" {
    #[doc = " Gets the name of the operation as an identifier."]
    pub fn mlirOperationGetName(op: MlirOperation) -> MlirIdentifier;
}
extern "C" {
    #[doc = " Gets the block that owns this operation, returning null if the operation is\n not owned."]
    pub fn mlirOperationGetBlock(op: MlirOperation) -> MlirBlock;
}
extern "C" {
    #[doc = " Gets the operation that owns this operation, returning null if the operation\n is not owned."]
    pub fn mlirOperationGetParentOperation(op: MlirOperation) -> MlirOperation;
}
extern "C" {
    #[doc = " Returns the number of regions attached to the given operation."]
    pub fn mlirOperationGetNumRegions(op: MlirOperation) -> isize;
}
extern "C" {
    #[doc = " Returns `pos`-th region attached to the operation."]
    pub fn mlirOperationGetRegion(op: MlirOperation, pos: isize) -> MlirRegion;
}
extern "C" {
    #[doc = " Returns an operation immediately following the given operation it its\n enclosing block."]
    pub fn mlirOperationGetNextInBlock(op: MlirOperation) -> MlirOperation;
}
extern "C" {
    #[doc = " Returns the number of operands of the operation."]
    pub fn mlirOperationGetNumOperands(op: MlirOperation) -> isize;
}
extern "C" {
    #[doc = " Returns `pos`-th operand of the operation."]
    pub fn mlirOperationGetOperand(op: MlirOperation, pos: isize) -> MlirValue;
}
extern "C" {
    #[doc = " Sets the `pos`-th operand of the operation."]
    pub fn mlirOperationSetOperand(op: MlirOperation, pos: isize, newValue: MlirValue);
}
extern "C" {
    #[doc = " Replaces the operands of the operation."]
    pub fn mlirOperationSetOperands(
        op: MlirOperation,
        nOperands: isize,
        operands: *const MlirValue,
    );
}
extern "C" {
    #[doc = " Returns the number of results of the operation."]
    pub fn mlirOperationGetNumResults(op: MlirOperation) -> isize;
}
extern "C" {
    #[doc = " Returns `pos`-th result of the operation."]
    pub fn mlirOperationGetResult(op: MlirOperation, pos: isize) -> MlirValue;
}
extern "C" {
    #[doc = " Returns the number of successor blocks of the operation."]
    pub fn mlirOperationGetNumSuccessors(op: MlirOperation) -> isize;
}
extern "C" {
    #[doc = " Returns `pos`-th successor of the operation."]
    pub fn mlirOperationGetSuccessor(op: MlirOperation, pos: isize) -> MlirBlock;
}
extern "C" {
    #[doc = " Set `pos`-th successor of the operation."]
    pub fn mlirOperationSetSuccessor(op: MlirOperation, pos: isize, block: MlirBlock);
}
extern "C" {
    #[doc = " Returns true if this operation defines an inherent attribute with this name.\n Note: the attribute can be optional, so\n `mlirOperationGetInherentAttributeByName` can still return a null attribute."]
    pub fn mlirOperationHasInherentAttributeByName(op: MlirOperation, name: MlirStringRef) -> bool;
}
extern "C" {
    #[doc = " Returns an inherent attribute attached to the operation given its name."]
    pub fn mlirOperationGetInherentAttributeByName(
        op: MlirOperation,
        name: MlirStringRef,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Sets an inherent attribute by name, replacing the existing if it exists.\n This has no effect if \"name\" does not match an inherent attribute."]
    pub fn mlirOperationSetInherentAttributeByName(
        op: MlirOperation,
        name: MlirStringRef,
        attr: MlirAttribute,
    );
}
extern "C" {
    #[doc = " Returns the number of discardable attributes attached to the operation."]
    pub fn mlirOperationGetNumDiscardableAttributes(op: MlirOperation) -> isize;
}
extern "C" {
    #[doc = " Return `pos`-th discardable attribute of the operation."]
    pub fn mlirOperationGetDiscardableAttribute(
        op: MlirOperation,
        pos: isize,
    ) -> MlirNamedAttribute;
}
extern "C" {
    #[doc = " Returns a discardable attribute attached to the operation given its name."]
    pub fn mlirOperationGetDiscardableAttributeByName(
        op: MlirOperation,
        name: MlirStringRef,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Sets a discardable attribute by name, replacing the existing if it exists or\n adding a new one otherwise. The new `attr` Attribute is not allowed to be\n null, use `mlirOperationRemoveDiscardableAttributeByName` to remove an\n Attribute instead."]
    pub fn mlirOperationSetDiscardableAttributeByName(
        op: MlirOperation,
        name: MlirStringRef,
        attr: MlirAttribute,
    );
}
extern "C" {
    #[doc = " Removes a discardable attribute by name. Returns false if the attribute was\n not found and true if removed."]
    pub fn mlirOperationRemoveDiscardableAttributeByName(
        op: MlirOperation,
        name: MlirStringRef,
    ) -> bool;
}
extern "C" {
    #[doc = " Returns the number of attributes attached to the operation.\n Deprecated, please use `mlirOperationGetNumInherentAttributes` or\n `mlirOperationGetNumDiscardableAttributes`."]
    pub fn mlirOperationGetNumAttributes(op: MlirOperation) -> isize;
}
extern "C" {
    #[doc = " Return `pos`-th attribute of the operation.\n Deprecated, please use `mlirOperationGetInherentAttribute` or\n `mlirOperationGetDiscardableAttribute`."]
    pub fn mlirOperationGetAttribute(op: MlirOperation, pos: isize) -> MlirNamedAttribute;
}
extern "C" {
    #[doc = " Returns an attribute attached to the operation given its name.\n Deprecated, please use `mlirOperationGetInherentAttributeByName` or\n `mlirOperationGetDiscardableAttributeByName`."]
    pub fn mlirOperationGetAttributeByName(op: MlirOperation, name: MlirStringRef)
        -> MlirAttribute;
}
extern "C" {
    #[doc = " Sets an attribute by name, replacing the existing if it exists or\n adding a new one otherwise.\n Deprecated, please use `mlirOperationSetInherentAttributeByName` or\n `mlirOperationSetDiscardableAttributeByName`."]
    pub fn mlirOperationSetAttributeByName(
        op: MlirOperation,
        name: MlirStringRef,
        attr: MlirAttribute,
    );
}
extern "C" {
    #[doc = " Removes an attribute by name. Returns false if the attribute was not found\n and true if removed.\n Deprecated, please use `mlirOperationRemoveInherentAttributeByName` or\n `mlirOperationRemoveDiscardableAttributeByName`."]
    pub fn mlirOperationRemoveAttributeByName(op: MlirOperation, name: MlirStringRef) -> bool;
}
extern "C" {
    #[doc = " Prints an operation by sending chunks of the string representation and\n forwarding `userData to `callback`. Note that the callback may be called\n several times with consecutive chunks of the string."]
    pub fn mlirOperationPrint(
        op: MlirOperation,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Same as mlirOperationPrint but accepts flags controlling the printing\n behavior."]
    pub fn mlirOperationPrintWithFlags(
        op: MlirOperation,
        flags: MlirOpPrintingFlags,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Same as mlirOperationPrint but accepts AsmState controlling the printing\n behavior as well as caching computed names."]
    pub fn mlirOperationPrintWithState(
        op: MlirOperation,
        state: MlirAsmState,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Same as mlirOperationPrint but writing the bytecode format."]
    pub fn mlirOperationWriteBytecode(
        op: MlirOperation,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Same as mlirOperationWriteBytecode but with writer config and returns\n failure only if desired bytecode could not be honored."]
    pub fn mlirOperationWriteBytecodeWithConfig(
        op: MlirOperation,
        config: MlirBytecodeWriterConfig,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> MlirLogicalResult;
}
extern "C" {
    #[doc = " Prints an operation to stderr."]
    pub fn mlirOperationDump(op: MlirOperation);
}
extern "C" {
    #[doc = " Verify the operation and return true if it passes, false if it fails."]
    pub fn mlirOperationVerify(op: MlirOperation) -> bool;
}
extern "C" {
    #[doc = " Moves the given operation immediately after the other operation in its\n parent block. The given operation may be owned by the caller or by its\n current block. The other operation must belong to a block. In any case, the\n ownership is transferred to the block of the other operation."]
    pub fn mlirOperationMoveAfter(op: MlirOperation, other: MlirOperation);
}
extern "C" {
    #[doc = " Moves the given operation immediately before the other operation in its\n parent block. The given operation may be owner by the caller or by its\n current block. The other operation must belong to a block. In any case, the\n ownership is transferred to the block of the other operation."]
    pub fn mlirOperationMoveBefore(op: MlirOperation, other: MlirOperation);
}
pub const MlirWalkResult_MlirWalkResultAdvance: MlirWalkResult = 0;
pub const MlirWalkResult_MlirWalkResultInterrupt: MlirWalkResult = 1;
pub const MlirWalkResult_MlirWalkResultSkip: MlirWalkResult = 2;
#[doc = " Operation walk result."]
pub type MlirWalkResult = ::std::os::raw::c_uint;
pub const MlirWalkOrder_MlirWalkPreOrder: MlirWalkOrder = 0;
pub const MlirWalkOrder_MlirWalkPostOrder: MlirWalkOrder = 1;
#[doc = " Traversal order for operation walk."]
pub type MlirWalkOrder = ::std::os::raw::c_uint;
#[doc = " Operation walker type. The handler is passed an (opaque) reference to an\n operation and a pointer to a `userData`."]
pub type MlirOperationWalkCallback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: MlirOperation,
        userData: *mut ::std::os::raw::c_void,
    ) -> MlirWalkResult,
>;
extern "C" {
    #[doc = " Walks operation `op` in `walkOrder` and calls `callback` on that operation.\n `*userData` is passed to the callback as well and can be used to tunnel some\n context or other data into the callback."]
    pub fn mlirOperationWalk(
        op: MlirOperation,
        callback: MlirOperationWalkCallback,
        userData: *mut ::std::os::raw::c_void,
        walkOrder: MlirWalkOrder,
    );
}
extern "C" {
    #[doc = " Creates a new empty region and transfers ownership to the caller."]
    pub fn mlirRegionCreate() -> MlirRegion;
}
extern "C" {
    #[doc = " Takes a region owned by the caller and destroys it."]
    pub fn mlirRegionDestroy(region: MlirRegion);
}
extern "C" {
    #[doc = " Checks whether two region handles point to the same region. This does not\n perform deep comparison."]
    pub fn mlirRegionEqual(region: MlirRegion, other: MlirRegion) -> bool;
}
extern "C" {
    #[doc = " Gets the first block in the region."]
    pub fn mlirRegionGetFirstBlock(region: MlirRegion) -> MlirBlock;
}
extern "C" {
    #[doc = " Takes a block owned by the caller and appends it to the given region."]
    pub fn mlirRegionAppendOwnedBlock(region: MlirRegion, block: MlirBlock);
}
extern "C" {
    #[doc = " Takes a block owned by the caller and inserts it at `pos` to the given\n region. This is an expensive operation that linearly scans the region,\n prefer insertAfter/Before instead."]
    pub fn mlirRegionInsertOwnedBlock(region: MlirRegion, pos: isize, block: MlirBlock);
}
extern "C" {
    #[doc = " Takes a block owned by the caller and inserts it after the (non-owned)\n reference block in the given region. The reference block must belong to the\n region. If the reference block is null, prepends the block to the region."]
    pub fn mlirRegionInsertOwnedBlockAfter(
        region: MlirRegion,
        reference: MlirBlock,
        block: MlirBlock,
    );
}
extern "C" {
    #[doc = " Takes a block owned by the caller and inserts it before the (non-owned)\n reference block in the given region. The reference block must belong to the\n region. If the reference block is null, appends the block to the region."]
    pub fn mlirRegionInsertOwnedBlockBefore(
        region: MlirRegion,
        reference: MlirBlock,
        block: MlirBlock,
    );
}
extern "C" {
    #[doc = " Returns first region attached to the operation."]
    pub fn mlirOperationGetFirstRegion(op: MlirOperation) -> MlirRegion;
}
extern "C" {
    #[doc = " Returns the region immediately following the given region in its parent\n operation."]
    pub fn mlirRegionGetNextInOperation(region: MlirRegion) -> MlirRegion;
}
extern "C" {
    #[doc = " Moves the entire content of the source region to the target region."]
    pub fn mlirRegionTakeBody(target: MlirRegion, source: MlirRegion);
}
extern "C" {
    #[doc = " Creates a new empty block with the given argument types and transfers\n ownership to the caller."]
    pub fn mlirBlockCreate(
        nArgs: isize,
        args: *const MlirType,
        locs: *const MlirLocation,
    ) -> MlirBlock;
}
extern "C" {
    #[doc = " Takes a block owned by the caller and destroys it."]
    pub fn mlirBlockDestroy(block: MlirBlock);
}
extern "C" {
    #[doc = " Detach a block from the owning region and assume ownership."]
    pub fn mlirBlockDetach(block: MlirBlock);
}
extern "C" {
    #[doc = " Checks whether two blocks handles point to the same block. This does not\n perform deep comparison."]
    pub fn mlirBlockEqual(block: MlirBlock, other: MlirBlock) -> bool;
}
extern "C" {
    #[doc = " Returns the closest surrounding operation that contains this block."]
    pub fn mlirBlockGetParentOperation(arg1: MlirBlock) -> MlirOperation;
}
extern "C" {
    #[doc = " Returns the region that contains this block."]
    pub fn mlirBlockGetParentRegion(block: MlirBlock) -> MlirRegion;
}
extern "C" {
    #[doc = " Returns the block immediately following the given block in its parent\n region."]
    pub fn mlirBlockGetNextInRegion(block: MlirBlock) -> MlirBlock;
}
extern "C" {
    #[doc = " Returns the first operation in the block."]
    pub fn mlirBlockGetFirstOperation(block: MlirBlock) -> MlirOperation;
}
extern "C" {
    #[doc = " Returns the terminator operation in the block or null if no terminator."]
    pub fn mlirBlockGetTerminator(block: MlirBlock) -> MlirOperation;
}
extern "C" {
    #[doc = " Takes an operation owned by the caller and appends it to the block."]
    pub fn mlirBlockAppendOwnedOperation(block: MlirBlock, operation: MlirOperation);
}
extern "C" {
    #[doc = " Takes an operation owned by the caller and inserts it as `pos` to the block.\n This is an expensive operation that scans the block linearly, prefer\n insertBefore/After instead."]
    pub fn mlirBlockInsertOwnedOperation(block: MlirBlock, pos: isize, operation: MlirOperation);
}
extern "C" {
    #[doc = " Takes an operation owned by the caller and inserts it after the (non-owned)\n reference operation in the given block. If the reference is null, prepends\n the operation. Otherwise, the reference must belong to the block."]
    pub fn mlirBlockInsertOwnedOperationAfter(
        block: MlirBlock,
        reference: MlirOperation,
        operation: MlirOperation,
    );
}
extern "C" {
    #[doc = " Takes an operation owned by the caller and inserts it before the (non-owned)\n reference operation in the given block. If the reference is null, appends\n the operation. Otherwise, the reference must belong to the block."]
    pub fn mlirBlockInsertOwnedOperationBefore(
        block: MlirBlock,
        reference: MlirOperation,
        operation: MlirOperation,
    );
}
extern "C" {
    #[doc = " Returns the number of arguments of the block."]
    pub fn mlirBlockGetNumArguments(block: MlirBlock) -> isize;
}
extern "C" {
    #[doc = " Appends an argument of the specified type to the block. Returns the newly\n added argument."]
    pub fn mlirBlockAddArgument(block: MlirBlock, type_: MlirType, loc: MlirLocation) -> MlirValue;
}
extern "C" {
    #[doc = " Inserts an argument of the specified type at a specified index to the block.\n Returns the newly added argument."]
    pub fn mlirBlockInsertArgument(
        block: MlirBlock,
        pos: isize,
        type_: MlirType,
        loc: MlirLocation,
    ) -> MlirValue;
}
extern "C" {
    #[doc = " Returns `pos`-th argument of the block."]
    pub fn mlirBlockGetArgument(block: MlirBlock, pos: isize) -> MlirValue;
}
extern "C" {
    #[doc = " Prints a block by sending chunks of the string representation and\n forwarding `userData to `callback`. Note that the callback may be called\n several times with consecutive chunks of the string."]
    pub fn mlirBlockPrint(
        block: MlirBlock,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Returns 1 if two values are equal, 0 otherwise."]
    pub fn mlirValueEqual(value1: MlirValue, value2: MlirValue) -> bool;
}
extern "C" {
    #[doc = " Returns 1 if the value is a block argument, 0 otherwise."]
    pub fn mlirValueIsABlockArgument(value: MlirValue) -> bool;
}
extern "C" {
    #[doc = " Returns 1 if the value is an operation result, 0 otherwise."]
    pub fn mlirValueIsAOpResult(value: MlirValue) -> bool;
}
extern "C" {
    #[doc = " Returns the block in which this value is defined as an argument. Asserts if\n the value is not a block argument."]
    pub fn mlirBlockArgumentGetOwner(value: MlirValue) -> MlirBlock;
}
extern "C" {
    #[doc = " Returns the position of the value in the argument list of its block."]
    pub fn mlirBlockArgumentGetArgNumber(value: MlirValue) -> isize;
}
extern "C" {
    #[doc = " Sets the type of the block argument to the given type."]
    pub fn mlirBlockArgumentSetType(value: MlirValue, type_: MlirType);
}
extern "C" {
    #[doc = " Returns an operation that produced this value as its result. Asserts if the\n value is not an op result."]
    pub fn mlirOpResultGetOwner(value: MlirValue) -> MlirOperation;
}
extern "C" {
    #[doc = " Returns the position of the value in the list of results of the operation\n that produced it."]
    pub fn mlirOpResultGetResultNumber(value: MlirValue) -> isize;
}
extern "C" {
    #[doc = " Returns the type of the value."]
    pub fn mlirValueGetType(value: MlirValue) -> MlirType;
}
extern "C" {
    #[doc = " Set the type of the value."]
    pub fn mlirValueSetType(value: MlirValue, type_: MlirType);
}
extern "C" {
    #[doc = " Prints the value to the standard error stream."]
    pub fn mlirValueDump(value: MlirValue);
}
extern "C" {
    #[doc = " Prints a value by sending chunks of the string representation and\n forwarding `userData to `callback`. Note that the callback may be called\n several times with consecutive chunks of the string."]
    pub fn mlirValuePrint(
        value: MlirValue,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Prints a value as an operand (i.e., the ValueID)."]
    pub fn mlirValuePrintAsOperand(
        value: MlirValue,
        state: MlirAsmState,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Returns an op operand representing the first use of the value, or a null op\n operand if there are no uses."]
    pub fn mlirValueGetFirstUse(value: MlirValue) -> MlirOpOperand;
}
extern "C" {
    #[doc = " Replace all uses of 'of' value with the 'with' value, updating anything in\n the IR that uses 'of' to use the other value instead.  When this returns\n there are zero uses of 'of'."]
    pub fn mlirValueReplaceAllUsesOfWith(of: MlirValue, with: MlirValue);
}
extern "C" {
    #[doc = " Returns whether the op operand is null."]
    pub fn mlirOpOperandIsNull(opOperand: MlirOpOperand) -> bool;
}
extern "C" {
    #[doc = " Returns the value of an op operand."]
    pub fn mlirOpOperandGetValue(opOperand: MlirOpOperand) -> MlirValue;
}
extern "C" {
    #[doc = " Returns the owner operation of an op operand."]
    pub fn mlirOpOperandGetOwner(opOperand: MlirOpOperand) -> MlirOperation;
}
extern "C" {
    #[doc = " Returns the operand number of an op operand."]
    pub fn mlirOpOperandGetOperandNumber(opOperand: MlirOpOperand) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Returns an op operand representing the next use of the value, or a null op\n operand if there is no next use."]
    pub fn mlirOpOperandGetNextUse(opOperand: MlirOpOperand) -> MlirOpOperand;
}
extern "C" {
    #[doc = " Parses a type. The type is owned by the context."]
    pub fn mlirTypeParseGet(context: MlirContext, type_: MlirStringRef) -> MlirType;
}
extern "C" {
    #[doc = " Gets the context that a type was created with."]
    pub fn mlirTypeGetContext(type_: MlirType) -> MlirContext;
}
extern "C" {
    #[doc = " Gets the type ID of the type."]
    pub fn mlirTypeGetTypeID(type_: MlirType) -> MlirTypeID;
}
extern "C" {
    #[doc = " Gets the dialect a type belongs to."]
    pub fn mlirTypeGetDialect(type_: MlirType) -> MlirDialect;
}
extern "C" {
    #[doc = " Checks if two types are equal."]
    pub fn mlirTypeEqual(t1: MlirType, t2: MlirType) -> bool;
}
extern "C" {
    #[doc = " Prints a location by sending chunks of the string representation and\n forwarding `userData to `callback`. Note that the callback may be called\n several times with consecutive chunks of the string."]
    pub fn mlirTypePrint(
        type_: MlirType,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Prints the type to the standard error stream."]
    pub fn mlirTypeDump(type_: MlirType);
}
extern "C" {
    #[doc = " Parses an attribute. The attribute is owned by the context."]
    pub fn mlirAttributeParseGet(context: MlirContext, attr: MlirStringRef) -> MlirAttribute;
}
extern "C" {
    #[doc = " Gets the context that an attribute was created with."]
    pub fn mlirAttributeGetContext(attribute: MlirAttribute) -> MlirContext;
}
extern "C" {
    #[doc = " Gets the type of this attribute."]
    pub fn mlirAttributeGetType(attribute: MlirAttribute) -> MlirType;
}
extern "C" {
    #[doc = " Gets the type id of the attribute."]
    pub fn mlirAttributeGetTypeID(attribute: MlirAttribute) -> MlirTypeID;
}
extern "C" {
    #[doc = " Gets the dialect of the attribute."]
    pub fn mlirAttributeGetDialect(attribute: MlirAttribute) -> MlirDialect;
}
extern "C" {
    #[doc = " Checks if two attributes are equal."]
    pub fn mlirAttributeEqual(a1: MlirAttribute, a2: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Prints an attribute by sending chunks of the string representation and\n forwarding `userData to `callback`. Note that the callback may be called\n several times with consecutive chunks of the string."]
    pub fn mlirAttributePrint(
        attr: MlirAttribute,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Prints the attribute to the standard error stream."]
    pub fn mlirAttributeDump(attr: MlirAttribute);
}
extern "C" {
    #[doc = " Associates an attribute with the name. Takes ownership of neither."]
    pub fn mlirNamedAttributeGet(name: MlirIdentifier, attr: MlirAttribute) -> MlirNamedAttribute;
}
extern "C" {
    #[doc = " Gets an identifier with the given string value."]
    pub fn mlirIdentifierGet(context: MlirContext, str_: MlirStringRef) -> MlirIdentifier;
}
extern "C" {
    #[doc = " Returns the context associated with this identifier"]
    pub fn mlirIdentifierGetContext(arg1: MlirIdentifier) -> MlirContext;
}
extern "C" {
    #[doc = " Checks whether two identifiers are the same."]
    pub fn mlirIdentifierEqual(ident: MlirIdentifier, other: MlirIdentifier) -> bool;
}
extern "C" {
    #[doc = " Gets the string value of the identifier."]
    pub fn mlirIdentifierStr(ident: MlirIdentifier) -> MlirStringRef;
}
extern "C" {
    #[doc = " Returns the name of the attribute used to store symbol names compatible with\n symbol tables."]
    pub fn mlirSymbolTableGetSymbolAttributeName() -> MlirStringRef;
}
extern "C" {
    #[doc = " Returns the name of the attribute used to store symbol visibility."]
    pub fn mlirSymbolTableGetVisibilityAttributeName() -> MlirStringRef;
}
extern "C" {
    #[doc = " Creates a symbol table for the given operation. If the operation does not\n have the SymbolTable trait, returns a null symbol table."]
    pub fn mlirSymbolTableCreate(operation: MlirOperation) -> MlirSymbolTable;
}
extern "C" {
    #[doc = " Destroys the symbol table created with mlirSymbolTableCreate. This does not\n affect the operations in the table."]
    pub fn mlirSymbolTableDestroy(symbolTable: MlirSymbolTable);
}
extern "C" {
    #[doc = " Looks up a symbol with the given name in the given symbol table and returns\n the operation that corresponds to the symbol. If the symbol cannot be found,\n returns a null operation."]
    pub fn mlirSymbolTableLookup(
        symbolTable: MlirSymbolTable,
        name: MlirStringRef,
    ) -> MlirOperation;
}
extern "C" {
    #[doc = " Inserts the given operation into the given symbol table. The operation must\n have the symbol trait. If the symbol table already has a symbol with the\n same name, renames the symbol being inserted to ensure name uniqueness. Note\n that this does not move the operation itself into the block of the symbol\n table operation, this should be done separately. Returns the name of the\n symbol after insertion."]
    pub fn mlirSymbolTableInsert(
        symbolTable: MlirSymbolTable,
        operation: MlirOperation,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Removes the given operation from the symbol table and erases it."]
    pub fn mlirSymbolTableErase(symbolTable: MlirSymbolTable, operation: MlirOperation);
}
extern "C" {
    #[doc = " Attempt to replace all uses that are nested within the given operation\n of the given symbol 'oldSymbol' with the provided 'newSymbol'. This does\n not traverse into nested symbol tables. Will fail atomically if there are\n any unknown operations that may be potential symbol tables."]
    pub fn mlirSymbolTableReplaceAllSymbolUses(
        oldSymbol: MlirStringRef,
        newSymbol: MlirStringRef,
        from: MlirOperation,
    ) -> MlirLogicalResult;
}
extern "C" {
    #[doc = " Walks all symbol table operations nested within, and including, `op`. For\n each symbol table operation, the provided callback is invoked with the op\n and a boolean signifying if the symbols within that symbol table can be\n treated as if all uses within the IR are visible to the caller.\n `allSymUsesVisible` identifies whether all of the symbol uses of symbols\n within `op` are visible."]
    pub fn mlirSymbolTableWalkSymbolTables(
        from: MlirOperation,
        allSymUsesVisible: bool,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: MlirOperation,
                arg2: bool,
                userData: *mut ::std::os::raw::c_void,
            ),
        >,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn registerCombPasses();
}
extern "C" {
    pub fn mlirGetDialectHandle__comb__() -> MlirDialectHandle;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWInstanceGraph {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_HWInstanceGraph() {
    const UNINIT: ::std::mem::MaybeUninit<HWInstanceGraph> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HWInstanceGraph>(),
        8usize,
        concat!("Size of: ", stringify!(HWInstanceGraph))
    );
    assert_eq!(
        ::std::mem::align_of::<HWInstanceGraph>(),
        8usize,
        concat!("Alignment of ", stringify!(HWInstanceGraph))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HWInstanceGraph),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWInstanceGraphNode {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_HWInstanceGraphNode() {
    const UNINIT: ::std::mem::MaybeUninit<HWInstanceGraphNode> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HWInstanceGraphNode>(),
        8usize,
        concat!("Size of: ", stringify!(HWInstanceGraphNode))
    );
    assert_eq!(
        ::std::mem::align_of::<HWInstanceGraphNode>(),
        8usize,
        concat!("Alignment of ", stringify!(HWInstanceGraphNode))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HWInstanceGraphNode),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWStructFieldInfo {
    pub name: MlirIdentifier,
    pub type_: MlirType,
}
#[test]
fn bindgen_test_layout_HWStructFieldInfo() {
    const UNINIT: ::std::mem::MaybeUninit<HWStructFieldInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HWStructFieldInfo>(),
        16usize,
        concat!("Size of: ", stringify!(HWStructFieldInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<HWStructFieldInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(HWStructFieldInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HWStructFieldInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HWStructFieldInfo),
            "::",
            stringify!(type_)
        )
    );
}
pub const HWModulePortDirection_Input: HWModulePortDirection = 0;
pub const HWModulePortDirection_Output: HWModulePortDirection = 1;
pub const HWModulePortDirection_InOut: HWModulePortDirection = 2;
pub type HWModulePortDirection = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWModulePort {
    pub name: MlirAttribute,
    pub type_: MlirType,
    pub dir: HWModulePortDirection,
}
#[test]
fn bindgen_test_layout_HWModulePort() {
    const UNINIT: ::std::mem::MaybeUninit<HWModulePort> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<HWModulePort>(),
        24usize,
        concat!("Size of: ", stringify!(HWModulePort))
    );
    assert_eq!(
        ::std::mem::align_of::<HWModulePort>(),
        8usize,
        concat!("Alignment of ", stringify!(HWModulePort))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HWModulePort),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HWModulePort),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dir) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HWModulePort),
            "::",
            stringify!(dir)
        )
    );
}
extern "C" {
    pub fn mlirGetDialectHandle__hw__() -> MlirDialectHandle;
}
extern "C" {
    #[doc = " Return the hardware bit width of a type. Does not reflect any encoding,\n padding, or storage scheme, just the bit (and wire width) of a\n statically-size type. Reflects the number of wires needed to transmit a\n value of this type. Returns -1 if the type is not known or cannot be\n statically computed."]
    pub fn hwGetBitWidth(arg1: MlirType) -> i64;
}
extern "C" {
    #[doc = " Return true if the specified type can be used as an HW value type, that is\n the set of types that can be composed together to represent synthesized,\n hardware but not marker types like InOutType or unknown types from other\n dialects."]
    pub fn hwTypeIsAValueType(arg1: MlirType) -> bool;
}
extern "C" {
    #[doc = " If the type is an HW array"]
    pub fn hwTypeIsAArrayType(arg1: MlirType) -> bool;
}
extern "C" {
    #[doc = " If the type is an HW inout."]
    pub fn hwTypeIsAInOut(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " If the type is an HW module type."]
    pub fn hwTypeIsAModuleType(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " If the type is an HW struct."]
    pub fn hwTypeIsAStructType(arg1: MlirType) -> bool;
}
extern "C" {
    #[doc = " If the type is an HW type alias."]
    pub fn hwTypeIsATypeAliasType(arg1: MlirType) -> bool;
}
extern "C" {
    #[doc = " If the type is an HW int."]
    pub fn hwTypeIsAIntType(arg1: MlirType) -> bool;
}
extern "C" {
    #[doc = " Creates a fixed-size HW array type in the context associated with element"]
    pub fn hwArrayTypeGet(element: MlirType, size: usize) -> MlirType;
}
extern "C" {
    #[doc = " returns the element type of an array type"]
    pub fn hwArrayTypeGetElementType(arg1: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " returns the size of an array type"]
    pub fn hwArrayTypeGetSize(arg1: MlirType) -> isize;
}
extern "C" {
    #[doc = " Creates an HW inout type in the context associated with element."]
    pub fn hwInOutTypeGet(element: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Returns the element type of an inout type."]
    pub fn hwInOutTypeGetElementType(arg1: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Creates an HW module type."]
    pub fn hwModuleTypeGet(
        ctx: MlirContext,
        numPorts: isize,
        ports: *const HWModulePort,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Get an HW module type's number of inputs."]
    pub fn hwModuleTypeGetNumInputs(type_: MlirType) -> isize;
}
extern "C" {
    #[doc = " Get an HW module type's input type at a specific index."]
    pub fn hwModuleTypeGetInputType(type_: MlirType, index: isize) -> MlirType;
}
extern "C" {
    #[doc = " Get an HW module type's input name at a specific index."]
    pub fn hwModuleTypeGetInputName(type_: MlirType, index: isize) -> MlirStringRef;
}
extern "C" {
    #[doc = " Get an HW module type's number of outputs."]
    pub fn hwModuleTypeGetNumOutputs(type_: MlirType) -> isize;
}
extern "C" {
    #[doc = " Get an HW module type's output type at a specific index."]
    pub fn hwModuleTypeGetOutputType(type_: MlirType, index: isize) -> MlirType;
}
extern "C" {
    #[doc = " Get an HW module type's output name at a specific index."]
    pub fn hwModuleTypeGetOutputName(type_: MlirType, index: isize) -> MlirStringRef;
}
extern "C" {
    #[doc = " Creates an HW struct type in the context associated with the elements."]
    pub fn hwStructTypeGet(
        ctx: MlirContext,
        numElements: isize,
        elements: *const HWStructFieldInfo,
    ) -> MlirType;
}
extern "C" {
    pub fn hwStructTypeGetField(structType: MlirType, fieldName: MlirStringRef) -> MlirType;
}
extern "C" {
    pub fn hwParamIntTypeGet(parameter: MlirAttribute) -> MlirType;
}
extern "C" {
    pub fn hwParamIntTypeGetWidthAttr(arg1: MlirType) -> MlirAttribute;
}
extern "C" {
    pub fn hwStructTypeGetFieldIndex(
        structType: MlirType,
        fieldName: MlirStringRef,
    ) -> MlirAttribute;
}
extern "C" {
    pub fn hwStructTypeGetFieldNum(
        structType: MlirType,
        idx: ::std::os::raw::c_uint,
    ) -> HWStructFieldInfo;
}
extern "C" {
    pub fn hwStructTypeGetNumFields(structType: MlirType) -> isize;
}
extern "C" {
    pub fn hwTypeAliasTypeGet(
        scope: MlirStringRef,
        name: MlirStringRef,
        innerType: MlirType,
    ) -> MlirType;
}
extern "C" {
    pub fn hwTypeAliasTypeGetCanonicalType(typeAlias: MlirType) -> MlirType;
}
extern "C" {
    pub fn hwTypeAliasTypeGetInnerType(typeAlias: MlirType) -> MlirType;
}
extern "C" {
    pub fn hwTypeAliasTypeGetName(typeAlias: MlirType) -> MlirStringRef;
}
extern "C" {
    pub fn hwTypeAliasTypeGetScope(typeAlias: MlirType) -> MlirStringRef;
}
extern "C" {
    pub fn hwAttrIsAInnerSymAttr(arg1: MlirAttribute) -> bool;
}
extern "C" {
    pub fn hwInnerSymAttrGet(symName: MlirAttribute) -> MlirAttribute;
}
extern "C" {
    pub fn hwInnerSymAttrGetSymName(arg1: MlirAttribute) -> MlirAttribute;
}
extern "C" {
    pub fn hwAttrIsAInnerRefAttr(arg1: MlirAttribute) -> bool;
}
extern "C" {
    pub fn hwInnerRefAttrGet(moduleName: MlirAttribute, innerSym: MlirAttribute) -> MlirAttribute;
}
extern "C" {
    pub fn hwInnerRefAttrGetName(arg1: MlirAttribute) -> MlirAttribute;
}
extern "C" {
    pub fn hwInnerRefAttrGetModule(arg1: MlirAttribute) -> MlirAttribute;
}
extern "C" {
    pub fn hwAttrIsAParamDeclAttr(arg1: MlirAttribute) -> bool;
}
extern "C" {
    pub fn hwParamDeclAttrGet(
        name: MlirStringRef,
        type_: MlirType,
        value: MlirAttribute,
    ) -> MlirAttribute;
}
extern "C" {
    pub fn hwParamDeclAttrGetName(decl: MlirAttribute) -> MlirStringRef;
}
extern "C" {
    pub fn hwParamDeclAttrGetType(decl: MlirAttribute) -> MlirType;
}
extern "C" {
    pub fn hwParamDeclAttrGetValue(decl: MlirAttribute) -> MlirAttribute;
}
extern "C" {
    pub fn hwAttrIsAParamDeclRefAttr(arg1: MlirAttribute) -> bool;
}
extern "C" {
    pub fn hwParamDeclRefAttrGet(ctx: MlirContext, cName: MlirStringRef) -> MlirAttribute;
}
extern "C" {
    pub fn hwParamDeclRefAttrGetName(decl: MlirAttribute) -> MlirStringRef;
}
extern "C" {
    pub fn hwParamDeclRefAttrGetType(decl: MlirAttribute) -> MlirType;
}
extern "C" {
    pub fn hwAttrIsAParamVerbatimAttr(arg1: MlirAttribute) -> bool;
}
extern "C" {
    pub fn hwParamVerbatimAttrGet(text: MlirAttribute) -> MlirAttribute;
}
extern "C" {
    pub fn hwAttrIsAOutputFileAttr(arg1: MlirAttribute) -> bool;
}
extern "C" {
    pub fn hwOutputFileGetFromFileName(
        text: MlirAttribute,
        excludeFromFileList: bool,
        includeReplicatedOp: bool,
    ) -> MlirAttribute;
}
extern "C" {
    pub fn hwInstanceGraphGet(operation: MlirOperation) -> HWInstanceGraph;
}
extern "C" {
    pub fn hwInstanceGraphDestroy(instanceGraph: HWInstanceGraph);
}
extern "C" {
    pub fn hwInstanceGraphGetTopLevelNode(instanceGraph: HWInstanceGraph) -> HWInstanceGraphNode;
}
pub type HWInstanceGraphNodeCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: HWInstanceGraphNode, arg2: *mut ::std::os::raw::c_void),
>;
extern "C" {
    pub fn hwInstanceGraphForEachNode(
        instanceGraph: HWInstanceGraph,
        callback: HWInstanceGraphNodeCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn hwInstanceGraphNodeEqual(lhs: HWInstanceGraphNode, rhs: HWInstanceGraphNode) -> bool;
}
extern "C" {
    pub fn hwInstanceGraphNodeGetModule(node: HWInstanceGraphNode) -> MlirModule;
}
extern "C" {
    pub fn hwInstanceGraphNodeGetModuleOp(node: HWInstanceGraphNode) -> MlirOperation;
}
extern "C" {
    pub fn mlirGetDialectHandle__llhd__() -> MlirDialectHandle;
}
extern "C" {
    #[doc = " Check if a type is a time type."]
    pub fn llhdTypeIsATimeType(arg1: MlirType) -> bool;
}
extern "C" {
    #[doc = " Check if a type is a signal type."]
    pub fn llhdTypeIsASignalType(arg1: MlirType) -> bool;
}
extern "C" {
    #[doc = " Check if a type is a pointer type."]
    pub fn llhdTypeIsAPointerType(arg1: MlirType) -> bool;
}
extern "C" {
    #[doc = " Create a time type."]
    pub fn llhdTimeTypeGet(ctx: MlirContext) -> MlirType;
}
extern "C" {
    #[doc = " Create a signal type."]
    pub fn llhdSignalTypeGet(element: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Create a pointer type."]
    pub fn llhdPointerTypeGet(element: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Get the inner type of a signal."]
    pub fn llhdSignalTypeGetElementType(arg1: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Get the inner type of a pointer."]
    pub fn llhdPointerTypeGetElementType(arg1: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Check if an attribute is a time attribute."]
    pub fn llhdAttrIsATimeAttr(arg1: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Create a time attribute."]
    pub fn llhdTimeAttrGet(
        ctx: MlirContext,
        timeUnit: MlirStringRef,
        seconds: u64,
        delta: u64,
        epsilon: u64,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Get the time unit of a time attribute."]
    pub fn llhdTimeAttrGetTimeUnit(arg1: MlirAttribute) -> MlirStringRef;
}
extern "C" {
    #[doc = " Get the seconds component of a time attribute."]
    pub fn llhdTimeAttrGetSeconds(arg1: MlirAttribute) -> u64;
}
extern "C" {
    #[doc = " Get the delta component of a time attribute."]
    pub fn llhdTimeAttrGetDelta(arg1: MlirAttribute) -> u64;
}
extern "C" {
    #[doc = " Get the epsilon component of a time attribute."]
    pub fn llhdTimeAttrGetEpsilon(arg1: MlirAttribute) -> u64;
}
extern "C" {
    pub fn mlirGetDialectHandle__seq__() -> MlirDialectHandle;
}
extern "C" {
    pub fn registerSeqPasses();
}
extern "C" {
    #[doc = " If the type is an clock type"]
    pub fn seqTypeIsAClock(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Creates an seq clock type"]
    pub fn seqClockTypeGet(ctx: MlirContext) -> MlirType;
}
extern "C" {
    pub fn mlirGetDialectHandle__moore__() -> MlirDialectHandle;
}
#[doc = " A `bit`."]
pub const MooreIntKind_MooreBit: MooreIntKind = 0;
#[doc = " A `logic`."]
pub const MooreIntKind_MooreLogic: MooreIntKind = 1;
#[doc = " A `reg`."]
pub const MooreIntKind_MooreReg: MooreIntKind = 2;
#[doc = " A `byte`."]
pub const MooreIntKind_MooreByte: MooreIntKind = 3;
#[doc = " A `shortint`."]
pub const MooreIntKind_MooreShortInt: MooreIntKind = 4;
#[doc = " An `int`."]
pub const MooreIntKind_MooreInt: MooreIntKind = 5;
#[doc = " A `longint`."]
pub const MooreIntKind_MooreLongInt: MooreIntKind = 6;
#[doc = " An `integer`."]
pub const MooreIntKind_MooreInteger: MooreIntKind = 7;
#[doc = " A `time`."]
pub const MooreIntKind_MooreTime: MooreIntKind = 8;
pub type MooreIntKind = ::std::os::raw::c_uint;
#[doc = " A `shortreal`."]
pub const MooreRealKind_MooreShortReal: MooreRealKind = 0;
#[doc = " A `real`."]
pub const MooreRealKind_MooreReal: MooreRealKind = 1;
#[doc = " A `realtime`."]
pub const MooreRealKind_MooreRealTime: MooreRealKind = 2;
pub type MooreRealKind = ::std::os::raw::c_uint;
#[doc = " No sign is explicitly given."]
pub const MooreSign_MooreNone: MooreSign = 0;
#[doc = " Explicitly marked to be unsigned."]
pub const MooreSign_MooreUnsigned: MooreSign = 1;
#[doc = " Explicitly marked to be signed."]
pub const MooreSign_MooreSigned: MooreSign = 2;
pub type MooreSign = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Create a void type."]
    pub fn mooreVoidTypeGet(ctx: MlirContext) -> MlirType;
}
extern "C" {
    #[doc = " Create a string type."]
    pub fn mooreStringTypeGet(ctx: MlirContext) -> MlirType;
}
extern "C" {
    #[doc = " Create a chandle type."]
    pub fn mooreChandleTypeGet(ctx: MlirContext) -> MlirType;
}
extern "C" {
    #[doc = " Create an event type."]
    pub fn mooreEventTypeGet(ctx: MlirContext) -> MlirType;
}
extern "C" {
    #[doc = " Create an int type."]
    pub fn mooreIntTypeGet(ctx: MlirContext, kind: MooreIntKind, sign: MooreSign) -> MlirType;
}
extern "C" {
    #[doc = " Create a `logic` type."]
    pub fn mooreIntTypeGetLogic(ctx: MlirContext) -> MlirType;
}
extern "C" {
    #[doc = " Create an `int` type."]
    pub fn mooreIntTypeGetInt(ctx: MlirContext) -> MlirType;
}
extern "C" {
    #[doc = " Create a `time` type."]
    pub fn mooreIntTypeGetTime(ctx: MlirContext) -> MlirType;
}
extern "C" {
    #[doc = " Create a real type."]
    pub fn mooreRealTypeGet(ctx: MlirContext, kind: MooreRealKind) -> MlirType;
}
extern "C" {
    #[doc = " Create a packed unsized dimension type."]
    pub fn moorePackedUnsizedDimTypeGet(inner: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Create a packed range dimension type."]
    pub fn moorePackedRangeDimTypeGet(
        inner: MlirType,
        size: ::std::os::raw::c_uint,
        upDir: bool,
        offset: ::std::os::raw::c_int,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Create a unpacked unsized dimension type."]
    pub fn mooreUnpackedUnsizedDimTypeGet(inner: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Create a unpacked array dimension type."]
    pub fn mooreUnpackedArrayDimTypeGet(inner: MlirType, size: ::std::os::raw::c_uint) -> MlirType;
}
extern "C" {
    #[doc = " Create a unpacked range dimension type."]
    pub fn mooreUnpackedRangeDimTypeGet(
        inner: MlirType,
        size: ::std::os::raw::c_uint,
        upDir: bool,
        offset: ::std::os::raw::c_int,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Create a unpacked assoc dimension type without index."]
    pub fn mooreUnpackedAssocDimTypeGet(inner: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Create a unpacked assoc dimension type width index."]
    pub fn mooreUnpackedAssocDimTypeGetWithIndex(inner: MlirType, indexType: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Create a unpacked queue dimension type without bound."]
    pub fn mooreUnpackedQueueDimTypeGet(inner: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Create a unpacked queue dimension type with bound."]
    pub fn mooreUnpackedQueueDimTypeGetWithBound(
        inner: MlirType,
        bound: ::std::os::raw::c_uint,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Create a enum type without base."]
    pub fn mooreEnumTypeGet(name: MlirAttribute, loc: MlirLocation) -> MlirType;
}
extern "C" {
    #[doc = " Create a enum type with base."]
    pub fn mooreEnumTypeGetWithBase(
        name: MlirAttribute,
        loc: MlirLocation,
        base: MlirType,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Create a simple bit-vector type."]
    pub fn mooreSimpleBitVectorTypeGet(
        ctx: MlirContext,
        isFourValued: bool,
        isSigned: bool,
        size: ::std::os::raw::c_uint,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Checks whether the passed UnpackedType is a four-valued type."]
    pub fn mooreIsFourValuedType(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Checks whether the passed type is a simple bit-vector."]
    pub fn mooreIsSimpleBitVectorType(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Returns the size of a simple bit-vector type in bits."]
    pub fn mooreGetSimpleBitVectorSize(type_: MlirType) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn it_works();
}
extern "C" {
    pub fn simplify(filename: *const ::std::os::raw::c_char);
}
